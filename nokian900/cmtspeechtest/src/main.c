/* main.c generated by valac 0.12.0-dirty, the Vala compiler
 * generated from main.vala, do not modify */

/*
 * (C) 2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 */

#include <glib.h>
#include <glib-object.h>
#include <cmtspeech.h>
#include <stdlib.h>
#include <string.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _cmtspeech_close0(var) ((var == NULL) ? NULL : (var = (cmtspeech_close (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))


extern GMainLoop* loop;
GMainLoop* loop = NULL;
extern GIOChannel* channel;
GIOChannel* channel = NULL;
extern cmtspeech_t* connection;
cmtspeech_t* connection = NULL;

void handleDataEvent (void);
const gchar* cmtspeech_state_to_string (gint self);
static const char* _cmtspeech_state_to_string (gint value);
void handleControlEvent (void);
const gchar* cmtspeech_transition_to_string (gint self);
static const char* _cmtspeech_transition_to_string (gint value);
gboolean onTimeout (void);
gboolean onInputFromChannel (GIOChannel* source, GIOCondition condition);
void _vala_main (void);
static gboolean _onInputFromChannel_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static gboolean _onTimeout_gsource_func (gpointer self);


static const char* _cmtspeech_state_to_string (gint value) {
	switch (value) {
		case CMTSPEECH_STATE_INVALID:
		return "CMTSPEECH_STATE_INVALID";
		case CMTSPEECH_STATE_DISCONNECTED:
		return "CMTSPEECH_STATE_DISCONNECTED";
		case CMTSPEECH_STATE_CONNECTED:
		return "CMTSPEECH_STATE_CONNECTED";
		case CMTSPEECH_STATE_ACTIVE_DL:
		return "CMTSPEECH_STATE_ACTIVE_DL";
		case CMTSPEECH_STATE_ACTIVE_DLUL:
		return "CMTSPEECH_STATE_ACTIVE_DLUL";
		case CMTSPEECH_STATE_TEST_RAMP_PING_ACTIVE:
		return "CMTSPEECH_STATE_TEST_RAMP_PING_ACTIVE";
	}
	return NULL;
}


void handleDataEvent (void) {
	gint _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	struct cmtspeech_buffer_s dlbuf = {0};
	struct cmtspeech_buffer_s ulbuf = {0};
	struct cmtspeech_buffer_s _tmp4_ = {0};
	gint _tmp5_;
	gint ok;
	_tmp0_ = cmtspeech_protocol_state (connection);
	_tmp1_ = _cmtspeech_state_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("handleDataEvent during protocol state ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	g_debug ("main.vala:11: %s", _tmp3_);
	_g_free0 (_tmp3_);
	memset (&dlbuf, 0, sizeof (struct cmtspeech_buffer_s));
	memset (&ulbuf, 0, sizeof (struct cmtspeech_buffer_s));
	_tmp5_ = cmtspeech_dl_buffer_acquire (connection, &_tmp4_);
	 (&dlbuf);
	dlbuf = _tmp4_;
	ok = _tmp5_;
	if (ok == 0) {
		gint _tmp6_;
		g_debug ("main.vala:19: received DL packet w/ %u bytes", (guint) dlbuf.count);
		_tmp6_ = cmtspeech_protocol_state (connection);
		if (_tmp6_ == CMTSPEECH_STATE_ACTIVE_DLUL) {
			struct cmtspeech_buffer_s _tmp7_ = {0};
			gint _tmp8_;
			g_debug ("main.vala:22: protocol state is ACTIVE_DLUL, uploading as well...");
			_tmp8_ = cmtspeech_ul_buffer_acquire (connection, &_tmp7_);
			 (&ulbuf);
			ulbuf = _tmp7_;
			ok = _tmp8_;
			if (ulbuf.pcount == dlbuf.pcount) {
				g_debug ("main.vala:26: looping DL packet to UL with %u payload bytes", (guint) dlbuf.pcount);
				memcpy (ulbuf.payload, dlbuf.payload, (gsize) dlbuf.pcount);
			}
			cmtspeech_ul_buffer_release (connection, &ulbuf);
		}
		cmtspeech_dl_buffer_release (connection, &dlbuf);
	}
	 (&ulbuf);
	 (&dlbuf);
}


static const char* _cmtspeech_transition_to_string (gint value) {
	switch (value) {
		case CMTSPEECH_TR_INVALID:
		return "CMTSPEECH_TR_INVALID";
		case CMTSPEECH_TR_0_NO_CHANGE:
		return "CMTSPEECH_TR_0_NO_CHANGE";
		case CMTSPEECH_TR_1_CONNECTED:
		return "CMTSPEECH_TR_1_CONNECTED";
		case CMTSPEECH_TR_2_DISCONNECTED:
		return "CMTSPEECH_TR_2_DISCONNECTED";
		case CMTSPEECH_TR_3_DL_START:
		return "CMTSPEECH_TR_3_DL_START";
		case CMTSPEECH_TR_4_DLUL_STOP:
		return "CMTSPEECH_TR_4_DLUL_STOP";
		case CMTSPEECH_TR_5_PARAM_UPDATE:
		return "CMTSPEECH_TR_5_PARAM_UPDATE";
		case CMTSPEECH_TR_6_TIMING_UPDATE:
		return "CMTSPEECH_TR_6_TIMING_UPDATE";
		case CMTSPEECH_TR_7_TIMING_UPDATE:
		return "CMTSPEECH_TR_7_TIMING_UPDATE";
		case CMTSPEECH_TR_10_RESET:
		return "CMTSPEECH_TR_10_RESET";
		case CMTSPEECH_TR_11_UL_STOP:
		return "CMTSPEECH_TR_11_UL_STOP";
		case CMTSPEECH_TR_12_UL_START:
		return "CMTSPEECH_TR_12_UL_START";
	}
	return NULL;
}


void handleControlEvent (void) {
	gint _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	struct cmtspeech_event_s event = {0};
	gint transition;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gint _tmp8_;
	_tmp0_ = cmtspeech_protocol_state (connection);
	_tmp1_ = _cmtspeech_state_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("handleControlEvent during protocol state ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	g_debug ("main.vala:37: %s", _tmp3_);
	_g_free0 (_tmp3_);
	memset (&event, 0, sizeof (struct cmtspeech_event_s));
	transition = 0;
	cmtspeech_read_event (connection, &event);
	_tmp4_ = g_strdup_printf ("%i", event.msg_type);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat ("read event, type is ", _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	g_debug ("main.vala:44: %s", _tmp7_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_tmp8_ = cmtspeech_event_to_state_transition (connection, &event);
	transition = _tmp8_;
	switch (transition) {
		case CMTSPEECH_TR_INVALID:
		{
			g_debug ("main.vala:50: ERROR: invalid state transition");
			break;
		}
		case CMTSPEECH_TR_1_CONNECTED:
		case CMTSPEECH_TR_2_DISCONNECTED:
		case CMTSPEECH_TR_3_DL_START:
		case CMTSPEECH_TR_4_DLUL_STOP:
		case CMTSPEECH_TR_5_PARAM_UPDATE:
		{
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_;
			_tmp9_ = _cmtspeech_transition_to_string (transition);
			_tmp10_ = g_strconcat ("state transition ok, new state is ", _tmp9_, NULL);
			_tmp11_ = _tmp10_;
			g_debug ("main.vala:58: %s", _tmp11_);
			_g_free0 (_tmp11_);
			break;
		}
		case CMTSPEECH_TR_6_TIMING_UPDATE:
		case CMTSPEECH_TR_7_TIMING_UPDATE:
		{
			g_debug ("main.vala:63: WARNING: modem UL timing update ignored");
			break;
		}
		case CMTSPEECH_TR_10_RESET:
		case CMTSPEECH_TR_11_UL_STOP:
		case CMTSPEECH_TR_12_UL_START:
		{
			const gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			_tmp12_ = _cmtspeech_transition_to_string (transition);
			_tmp13_ = g_strconcat ("state transition ok, new state is ", _tmp12_, NULL);
			_tmp14_ = _tmp13_;
			g_debug ("main.vala:69: %s", _tmp14_);
			_g_free0 (_tmp14_);
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	 (&event);
}


gboolean onTimeout (void) {
	gboolean result = FALSE;
	if (connection != NULL) {
		gint _tmp0_;
		gint ok;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp0_ = cmtspeech_state_change_call_status (connection, TRUE);
		ok = _tmp0_;
		_tmp1_ = g_strdup_printf ("%i", ok);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_strconcat ("change call state returned: ", _tmp2_, NULL);
		_tmp4_ = _tmp3_;
		g_debug ("main.vala:82: %s", _tmp4_);
		_g_free0 (_tmp4_);
		_g_free0 (_tmp2_);
	}
	result = FALSE;
	return result;
}


gboolean onInputFromChannel (GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint flags;
	gint _tmp1_;
	gint _tmp2_;
	gint ok;
	g_return_val_if_fail (source != NULL, FALSE);
	g_debug ("main.vala:90: onInputFromChannel, condition = %d", (gint) condition);
	if (condition == G_IO_HUP) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = condition == G_IO_IN;
	}
	g_assert (_tmp0_);
	if (condition == G_IO_HUP) {
		g_debug ("main.vala:96: HUP, closing");
		g_main_loop_quit (loop);
		result = FALSE;
		return result;
	}
	flags = 0;
	_tmp2_ = cmtspeech_check_pending (connection, &_tmp1_);
	flags = _tmp1_;
	ok = _tmp2_;
	if (ok < 0) {
		g_debug ("main.vala:105: error while checking for pending events...");
	} else {
		if (ok == 0) {
			g_debug ("main.vala:109: D'oh, cmt speech readable, but no events pending...");
		} else {
			g_debug ("main.vala:113: connection reports pending events with flags 0x%0X", (guint) flags);
			if ((flags & CMTSPEECH_EVENT_DL_DATA) == CMTSPEECH_EVENT_DL_DATA) {
				handleDataEvent ();
			} else {
				if ((flags & CMTSPEECH_EVENT_CONTROL) == CMTSPEECH_EVENT_CONTROL) {
					handleControlEvent ();
				} else {
					g_debug ("main.vala:125: event no DL_DATA nor CONTROL, ignoring");
				}
			}
		}
	}
	result = TRUE;
	return result;
}


static gboolean _onInputFromChannel_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = onInputFromChannel (source, condition);
	return result;
}


static gboolean _onTimeout_gsource_func (gpointer self) {
	gboolean result;
	result = onTimeout ();
	return result;
}


void _vala_main (void) {
	cmtspeech_t* _tmp0_ = NULL;
	gint _tmp1_;
	gint fd;
	GMainLoop* _tmp2_ = NULL;
	GIOChannel* _tmp3_ = NULL;
	g_debug ("main.vala:134: initializing cmtspeed");
	cmtspeech_init ();
	g_debug ("main.vala:137: setting up traces");
	cmtspeech_trace_toggle (CMTSPEECH_TRACE_STATE_CHANGE, TRUE);
	cmtspeech_trace_toggle (CMTSPEECH_TRACE_IO, TRUE);
	cmtspeech_trace_toggle (CMTSPEECH_TRACE_DEBUG, TRUE);
	g_debug ("main.vala:142: instanciating connection");
	_tmp0_ = cmtspeech_open ();
	_cmtspeech_close0 (connection);
	connection = _tmp0_;
	if (connection == NULL) {
		g_error ("main.vala:146: Can't instanciate connection");
	}
	_tmp1_ = cmtspeech_descriptor (connection);
	fd = _tmp1_;
	if (fd == (-1)) {
		g_error ("main.vala:152: File descriptor invalid");
	}
	g_debug ("main.vala:155: creating channel and mainloop");
	_tmp2_ = g_main_loop_new (NULL, FALSE);
	_g_main_loop_unref0 (loop);
	loop = _tmp2_;
	_tmp3_ = g_io_channel_unix_new (fd);
	_g_io_channel_unref0 (channel);
	channel = _tmp3_;
	g_io_add_watch (channel, G_IO_IN | G_IO_HUP, _onInputFromChannel_gio_func, NULL);
	g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, (guint) 3, _onTimeout_gsource_func, NULL, NULL);
	g_debug ("main.vala:163: --> loop");
	g_main_loop_run (loop);
	g_debug ("main.vala:165: <-- loop");
}


int main (int argc, char ** argv) {
	g_type_init ();
	_vala_main ();
	return 0;
}



