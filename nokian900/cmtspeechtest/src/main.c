/* main.c generated by valac 0.12.0-dirty, the Vala compiler
 * generated from main.vala, do not modify */

/*
 * (C) 2011 Michael 'Mickey' Lauer <mlauer@vanille-media.de>
 */

#include <glib.h>
#include <glib-object.h>
#include <cmtspeech.h>
#include <freesmartphone.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <gio/gio.h>

#define _g_free0(var) (var = (g_free (var), NULL))
#define _cmtspeech_close0(var) ((var == NULL) ? NULL : (var = (cmtspeech_close (var), NULL)))
#define _g_main_loop_unref0(var) ((var == NULL) ? NULL : (var = (g_main_loop_unref (var), NULL)))
#define _g_io_channel_unref0(var) ((var == NULL) ? NULL : (var = (g_io_channel_unref (var), NULL)))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))


extern GMainLoop* loop;
GMainLoop* loop = NULL;
extern GIOChannel* channel;
GIOChannel* channel = NULL;
extern cmtspeech_t* connection;
cmtspeech_t* connection = NULL;
extern FreeSmartphoneGSMCall* gsmcallproxy;
FreeSmartphoneGSMCall* gsmcallproxy = NULL;

void onCallStatusSignal (gint id, FreeSmartphoneGSMCallStatus status, GHashTable* properties);
const gchar* free_smartphone_gsm_call_status_to_string (FreeSmartphoneGSMCallStatus self);
void handleDataEvent (void);
const gchar* cmtspeech_state_to_string (gint self);
static const char* _cmtspeech_state_to_string (gint value);
void handleControlEvent (void);
const gchar* cmtspeech_transition_to_string (gint self);
static const char* _cmtspeech_transition_to_string (gint value);
gboolean onTimeout (void);
gboolean onInputFromChannel (GIOChannel* source, GIOCondition condition);
void SIGINT_handler (gint signum);
void _vala_main (void);
static void _SIGINT_handler_sighandler_t (gint signal);
static gboolean _onInputFromChannel_gio_func (GIOChannel* source, GIOCondition condition, gpointer self);
static void _onCallStatusSignal_free_smartphone_gsm_call_call_status (FreeSmartphoneGSMCall* _sender, gint id, FreeSmartphoneGSMCallStatus status, GHashTable* properties, gpointer self);


void onCallStatusSignal (gint id, FreeSmartphoneGSMCallStatus status, GHashTable* properties) {
	gchar* _tmp0_ = NULL;
	gchar* _tmp1_;
	GEnumValue* _tmp2_;
	gchar* _tmp3_ = NULL;
	gchar* _tmp4_;
	g_return_if_fail (properties != NULL);
	_tmp0_ = g_strdup_printf ("%i", id);
	_tmp1_ = _tmp0_;
	_tmp2_ = g_enum_get_value (g_type_class_ref (FREE_SMARTPHONE_GSM_TYPE_CALL_STATUS), status);
	_tmp3_ = g_strconcat ("onCallStatusSignal ", _tmp1_, " w/ status ", (_tmp2_ != NULL) ? _tmp2_->value_name : NULL, NULL);
	_tmp4_ = _tmp3_;
	g_debug ("main.vala:13: %s", _tmp4_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp1_);
	switch (status) {
		case FREE_SMARTPHONE_GSM_CALL_STATUS_OUTGOING:
		case FREE_SMARTPHONE_GSM_CALL_STATUS_ACTIVE:
		{
			cmtspeech_state_change_call_status (connection, TRUE);
			break;
		}
		case FREE_SMARTPHONE_GSM_CALL_STATUS_INCOMING:
		case FREE_SMARTPHONE_GSM_CALL_STATUS_RELEASE:
		{
			cmtspeech_state_change_call_status (connection, FALSE);
			break;
		}
		default:
		{
			GEnumValue* _tmp5_;
			gchar* _tmp6_ = NULL;
			gchar* _tmp7_;
			_tmp5_ = g_enum_get_value (g_type_class_ref (FREE_SMARTPHONE_GSM_TYPE_CALL_STATUS), status);
			_tmp6_ = g_strconcat ("Unhandled call status ", (_tmp5_ != NULL) ? _tmp5_->value_name : NULL, NULL);
			_tmp7_ = _tmp6_;
			g_debug ("main.vala:27: %s", _tmp7_);
			_g_free0 (_tmp7_);
			break;
		}
	}
}


static const char* _cmtspeech_state_to_string (gint value) {
	switch (value) {
		case CMTSPEECH_STATE_INVALID:
		return "CMTSPEECH_STATE_INVALID";
		case CMTSPEECH_STATE_DISCONNECTED:
		return "CMTSPEECH_STATE_DISCONNECTED";
		case CMTSPEECH_STATE_CONNECTED:
		return "CMTSPEECH_STATE_CONNECTED";
		case CMTSPEECH_STATE_ACTIVE_DL:
		return "CMTSPEECH_STATE_ACTIVE_DL";
		case CMTSPEECH_STATE_ACTIVE_DLUL:
		return "CMTSPEECH_STATE_ACTIVE_DLUL";
		case CMTSPEECH_STATE_TEST_RAMP_PING_ACTIVE:
		return "CMTSPEECH_STATE_TEST_RAMP_PING_ACTIVE";
	}
	return NULL;
}


void handleDataEvent (void) {
	gint _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	struct cmtspeech_buffer_s dlbuf = {0};
	struct cmtspeech_buffer_s ulbuf = {0};
	struct cmtspeech_buffer_s _tmp4_ = {0};
	gint _tmp5_;
	gint ok;
	_tmp0_ = cmtspeech_protocol_state (connection);
	_tmp1_ = _cmtspeech_state_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("handleDataEvent during protocol state ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	g_debug ("main.vala:35: %s", _tmp3_);
	_g_free0 (_tmp3_);
	memset (&dlbuf, 0, sizeof (struct cmtspeech_buffer_s));
	memset (&ulbuf, 0, sizeof (struct cmtspeech_buffer_s));
	_tmp5_ = cmtspeech_dl_buffer_acquire (connection, &_tmp4_);
	 (&dlbuf);
	dlbuf = _tmp4_;
	ok = _tmp5_;
	if (ok == 0) {
		gint _tmp6_;
		g_debug ("main.vala:43: received DL packet w/ %u bytes", (guint) dlbuf.count);
		_tmp6_ = cmtspeech_protocol_state (connection);
		if (_tmp6_ == CMTSPEECH_STATE_ACTIVE_DLUL) {
			struct cmtspeech_buffer_s _tmp7_ = {0};
			gint _tmp8_;
			g_debug ("main.vala:46: protocol state is ACTIVE_DLUL, uploading as well...");
			_tmp8_ = cmtspeech_ul_buffer_acquire (connection, &_tmp7_);
			 (&ulbuf);
			ulbuf = _tmp7_;
			ok = _tmp8_;
			if (ulbuf.pcount == dlbuf.pcount) {
				g_debug ("main.vala:50: looping DL packet to UL with %u payload bytes", (guint) dlbuf.pcount);
				memcpy (ulbuf.payload, dlbuf.payload, (gsize) dlbuf.pcount);
			}
			cmtspeech_ul_buffer_release (connection, &ulbuf);
		}
		cmtspeech_dl_buffer_release (connection, &dlbuf);
	}
	 (&ulbuf);
	 (&dlbuf);
}


static const char* _cmtspeech_transition_to_string (gint value) {
	switch (value) {
		case CMTSPEECH_TR_INVALID:
		return "CMTSPEECH_TR_INVALID";
		case CMTSPEECH_TR_0_NO_CHANGE:
		return "CMTSPEECH_TR_0_NO_CHANGE";
		case CMTSPEECH_TR_1_CONNECTED:
		return "CMTSPEECH_TR_1_CONNECTED";
		case CMTSPEECH_TR_2_DISCONNECTED:
		return "CMTSPEECH_TR_2_DISCONNECTED";
		case CMTSPEECH_TR_3_DL_START:
		return "CMTSPEECH_TR_3_DL_START";
		case CMTSPEECH_TR_4_DLUL_STOP:
		return "CMTSPEECH_TR_4_DLUL_STOP";
		case CMTSPEECH_TR_5_PARAM_UPDATE:
		return "CMTSPEECH_TR_5_PARAM_UPDATE";
		case CMTSPEECH_TR_6_TIMING_UPDATE:
		return "CMTSPEECH_TR_6_TIMING_UPDATE";
		case CMTSPEECH_TR_7_TIMING_UPDATE:
		return "CMTSPEECH_TR_7_TIMING_UPDATE";
		case CMTSPEECH_TR_10_RESET:
		return "CMTSPEECH_TR_10_RESET";
		case CMTSPEECH_TR_11_UL_STOP:
		return "CMTSPEECH_TR_11_UL_STOP";
		case CMTSPEECH_TR_12_UL_START:
		return "CMTSPEECH_TR_12_UL_START";
	}
	return NULL;
}


void handleControlEvent (void) {
	gint _tmp0_;
	const gchar* _tmp1_ = NULL;
	gchar* _tmp2_ = NULL;
	gchar* _tmp3_;
	struct cmtspeech_event_s event = {0};
	gint transition;
	gchar* _tmp4_ = NULL;
	gchar* _tmp5_;
	gchar* _tmp6_ = NULL;
	gchar* _tmp7_;
	gint _tmp8_;
	_tmp0_ = cmtspeech_protocol_state (connection);
	_tmp1_ = _cmtspeech_state_to_string (_tmp0_);
	_tmp2_ = g_strconcat ("handleControlEvent during protocol state ", _tmp1_, NULL);
	_tmp3_ = _tmp2_;
	g_debug ("main.vala:62: %s", _tmp3_);
	_g_free0 (_tmp3_);
	memset (&event, 0, sizeof (struct cmtspeech_event_s));
	transition = 0;
	cmtspeech_read_event (connection, &event);
	_tmp4_ = g_strdup_printf ("%i", event.msg_type);
	_tmp5_ = _tmp4_;
	_tmp6_ = g_strconcat ("read event, type is ", _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	g_debug ("main.vala:69: %s", _tmp7_);
	_g_free0 (_tmp7_);
	_g_free0 (_tmp5_);
	_tmp8_ = cmtspeech_event_to_state_transition (connection, &event);
	transition = _tmp8_;
	switch (transition) {
		case CMTSPEECH_TR_INVALID:
		{
			g_debug ("main.vala:75: ERROR: invalid state transition");
			break;
		}
		case CMTSPEECH_TR_1_CONNECTED:
		case CMTSPEECH_TR_2_DISCONNECTED:
		case CMTSPEECH_TR_3_DL_START:
		case CMTSPEECH_TR_4_DLUL_STOP:
		case CMTSPEECH_TR_5_PARAM_UPDATE:
		{
			const gchar* _tmp9_ = NULL;
			gchar* _tmp10_ = NULL;
			gchar* _tmp11_;
			_tmp9_ = _cmtspeech_transition_to_string (transition);
			_tmp10_ = g_strconcat ("state transition ok, new state is ", _tmp9_, NULL);
			_tmp11_ = _tmp10_;
			g_debug ("main.vala:83: %s", _tmp11_);
			_g_free0 (_tmp11_);
			break;
		}
		case CMTSPEECH_TR_6_TIMING_UPDATE:
		case CMTSPEECH_TR_7_TIMING_UPDATE:
		{
			g_debug ("main.vala:88: WARNING: modem UL timing update ignored");
			break;
		}
		case CMTSPEECH_TR_10_RESET:
		case CMTSPEECH_TR_11_UL_STOP:
		case CMTSPEECH_TR_12_UL_START:
		{
			const gchar* _tmp12_ = NULL;
			gchar* _tmp13_ = NULL;
			gchar* _tmp14_;
			_tmp12_ = _cmtspeech_transition_to_string (transition);
			_tmp13_ = g_strconcat ("state transition ok, new state is ", _tmp12_, NULL);
			_tmp14_ = _tmp13_;
			g_debug ("main.vala:94: %s", _tmp14_);
			_g_free0 (_tmp14_);
			break;
		}
		default:
		{
			g_assert_not_reached ();
		}
	}
	 (&event);
}


gboolean onTimeout (void) {
	gboolean result = FALSE;
	if (connection != NULL) {
		gint _tmp0_;
		gint ok;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		gchar* _tmp3_ = NULL;
		gchar* _tmp4_;
		_tmp0_ = cmtspeech_state_change_call_status (connection, TRUE);
		ok = _tmp0_;
		_tmp1_ = g_strdup_printf ("%i", ok);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_strconcat ("change call state returned: ", _tmp2_, NULL);
		_tmp4_ = _tmp3_;
		g_debug ("main.vala:108: %s", _tmp4_);
		_g_free0 (_tmp4_);
		_g_free0 (_tmp2_);
	}
	result = FALSE;
	return result;
}


gboolean onInputFromChannel (GIOChannel* source, GIOCondition condition) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gint flags;
	gint _tmp1_;
	gint _tmp2_;
	gint ok;
	g_return_val_if_fail (source != NULL, FALSE);
	g_debug ("main.vala:117: onInputFromChannel, condition = %d", (gint) condition);
	if (condition == G_IO_HUP) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = condition == G_IO_IN;
	}
	g_assert (_tmp0_);
	if (condition == G_IO_HUP) {
		g_debug ("main.vala:123: HUP, closing");
		g_main_loop_quit (loop);
		result = FALSE;
		return result;
	}
	flags = 0;
	_tmp2_ = cmtspeech_check_pending (connection, &_tmp1_);
	flags = _tmp1_;
	ok = _tmp2_;
	if (ok < 0) {
		g_debug ("main.vala:132: error while checking for pending events...");
	} else {
		if (ok == 0) {
			g_debug ("main.vala:136: D'oh, cmt speech readable, but no events pending...");
		} else {
			g_debug ("main.vala:140: connection reports pending events with flags 0x%0X", (guint) flags);
			if ((flags & CMTSPEECH_EVENT_DL_DATA) == CMTSPEECH_EVENT_DL_DATA) {
				handleDataEvent ();
			} else {
				if ((flags & CMTSPEECH_EVENT_CONTROL) == CMTSPEECH_EVENT_CONTROL) {
					handleControlEvent ();
				} else {
					g_debug ("main.vala:152: event no DL_DATA nor CONTROL, ignoring");
				}
			}
		}
	}
	result = TRUE;
	return result;
}


void SIGINT_handler (gint signum) {
	g_main_loop_quit (loop);
}


static void _SIGINT_handler_sighandler_t (gint signal) {
	SIGINT_handler (signal);
}


static gboolean _onInputFromChannel_gio_func (GIOChannel* source, GIOCondition condition, gpointer self) {
	gboolean result;
	result = onInputFromChannel (source, condition);
	return result;
}


static void _onCallStatusSignal_free_smartphone_gsm_call_call_status (FreeSmartphoneGSMCall* _sender, gint id, FreeSmartphoneGSMCallStatus status, GHashTable* properties, gpointer self) {
	onCallStatusSignal (id, status, properties);
}


static const gchar* string_to_string (const gchar* self) {
	const gchar* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	result = self;
	return result;
}


void _vala_main (void) {
	cmtspeech_t* _tmp0_ = NULL;
	gint _tmp1_;
	gint fd;
	GMainLoop* _tmp2_ = NULL;
	GIOChannel* _tmp3_ = NULL;
	FreeSmartphoneGSMCall* _tmp4_ = NULL;
	FreeSmartphoneGSMCall* _tmp5_;
	GError * _inner_error_ = NULL;
	signal (SIGINT, _SIGINT_handler_sighandler_t);
	g_debug ("main.vala:170: initializing cmtspeed");
	cmtspeech_init ();
	g_debug ("main.vala:173: setting up traces");
	cmtspeech_trace_toggle (CMTSPEECH_TRACE_STATE_CHANGE, TRUE);
	cmtspeech_trace_toggle (CMTSPEECH_TRACE_IO, TRUE);
	cmtspeech_trace_toggle (CMTSPEECH_TRACE_DEBUG, TRUE);
	g_debug ("main.vala:178: instanciating connection");
	_tmp0_ = cmtspeech_open ();
	_cmtspeech_close0 (connection);
	connection = _tmp0_;
	if (connection == NULL) {
		g_error ("main.vala:182: Can't instanciate connection");
	}
	_tmp1_ = cmtspeech_descriptor (connection);
	fd = _tmp1_;
	if (fd == (-1)) {
		g_error ("main.vala:189: File descriptor invalid");
	}
	g_debug ("main.vala:191: creating channel and mainloop");
	_tmp2_ = g_main_loop_new (NULL, FALSE);
	_g_main_loop_unref0 (loop);
	loop = _tmp2_;
	_tmp3_ = g_io_channel_unix_new (fd);
	_g_io_channel_unref0 (channel);
	channel = _tmp3_;
	g_io_add_watch (channel, G_IO_IN | G_IO_HUP, _onInputFromChannel_gio_func, NULL);
	g_debug ("main.vala:197: hooking on to fsogsmd");
	_tmp4_ = g_initable_new (FREE_SMARTPHONE_GSM_TYPE_CALL_PROXY, NULL, &_inner_error_, "g-flags", G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START, "g-name", "org.freesmartphone.ogsmd", "g-bus-type", G_BUS_TYPE_SYSTEM, "g-object-path", "/org/freesmartphone/GSM/Device", "g-interface-name", "org.freesmartphone.GSM.Call", NULL);
	_tmp5_ = (FreeSmartphoneGSMCall*) _tmp4_;
	if (_inner_error_ != NULL) {
		goto __catch0_g_error;
	}
	_g_object_unref0 (gsmcallproxy);
	gsmcallproxy = _tmp5_;
	g_signal_connect (gsmcallproxy, "call-status", (GCallback) _onCallStatusSignal_free_smartphone_gsm_call_call_status, NULL);
	goto __finally0;
	__catch0_g_error:
	{
		GError * e;
		const gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp6_ = string_to_string (e->message);
		_tmp7_ = g_strconcat ("Could not hook to fsogsmd: ", _tmp6_, NULL);
		_tmp8_ = _tmp7_;
		g_error ("main.vala:205: %s", _tmp8_);
		_g_free0 (_tmp8_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return;
	}
	g_debug ("main.vala:208: --> loop");
	g_main_loop_run (loop);
	g_debug ("main.vala:210: <-- loop");
	_cmtspeech_close0 (connection);
	connection = NULL;
	_g_io_channel_unref0 (channel);
	channel = NULL;
	_g_main_loop_unref0 (loop);
	loop = NULL;
}


int main (int argc, char ** argv) {
	g_type_init ();
	_vala_main ();
	return 0;
}



